/* $Id$ */
/*
 * nesc.cup
 *
 * Network Embedded Sensor Testbed (NESTBed)
 *
 * Copyright (C) 2006
 * Dependable Systems Research Group
 * Department of Computer Science
 * Clemson University
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License
 * as published by the Free Software Foundation; either version 2
 * of the License, or (at your option) any later version.
 * 
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 * 
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the
 *
 * Free Software Foundation, Inc.
 * 51 Franklin Street, Fifth Floor
 * Boston, MA  02110-1301, USA.
 */
package edu.clemson.cs.nestbed.server.nesc.parser;

import java_cup.runtime.*;
import edu.clemson.cs.nestbed.server.nesc.parser.ast.*;

parser code {:
    private Lexer     lexer;
    private Component component;

    public Parser(Lexer lexer) {
        this.lexer = lexer;
    }

    public void setComponent(Component component) {
        this.component = component;
    }

    public Component getComponent() {
        return component;
    }

    /* Change the method report_error so it will display the line
     * and column of where the error occurred in the input as well
     * as the reason for the error which is passed into the method
     * in the String 'message'.  */
    public void report_error(String message, Object info) {

        /* Create a StringBuffer called 'm' with the string 'Error' in it. */
        StringBuffer m = new StringBuffer("Error");

        /* Check if the information passed to the method is the same type
         * as the type java_cup.runtime.Symbol.  */ 
        if (info instanceof java_cup.runtime.Symbol) {

            /* Declare a java_cup.runtime.Symbol object 's' with the
             * information in the object info that is being typecasted
             * as a java_cup.runtime.Symbol object.  */
            java_cup.runtime.Symbol s = ((java_cup.runtime.Symbol) info);

            /* Check if the line number in the input is greater or
             * equal to zero.  */
            if (s.left >= 0) {

                /* Add to the end of the StringBuffer error message the
                 * line number of the error in the input. */
                m.append(" in line " + (s.left + 1));

                /* Check if the column number in the input is greater
                 * or equal to zero */
                if (s.right >= 0) {

                    /* Add to the end of the StringBuffer error message
                     * the column number of the error in the input.  */
                    m.append(", column " + (s.right + 1));
                }
            }
        }

        /* Add to the end of the StringBuffer error message created in this
           method the message that was passed into this method. */
        m.append(" : " + message);

        /* Print the contents of the StringBuffer 'm', which contains an
         * error message out on a line. */
        System.err.println(m);
    }


    /* Change the method report_fatal_error so when it reports a fatal
     * error it will display the line and column number of where the fatal
     * error occurred in the input as well as the reason for the fatal
     * error which is passed into the method in the object 'message' and
     * then exit.*/
    public void report_fatal_error(String message, Object info) {
        report_error(message, info);
        System.exit(1);
    }
:};




/* Use the scanner created with JFlex  */
scan with {:
    return lexer.next_token();
:};



/* ------------Declaration of Terminals and Non Terminals Section----------- */

/* Terminals (tokens returned by the scanner).
 *
 * Terminals that have no value are listed first and then terminals that
 * do have an value, in this case an integer value, are listed on the
 * next line down.
 */ 
terminal INCLUDES;
terminal CONFIGURATION;
terminal PROVIDES;
terminal USES;
terminal INTERFACE;
terminal IMPLEMENTATION;
terminal COMPONENTS;
terminal AS;
terminal STRING;
terminal SEMI_COLON;
terminal OPEN_PAREN;
terminal CLOSE_PAREN;
terminal OPEN_CURLY;
terminal CLOSE_CURLY;
terminal COMMA;
terminal DOT;
terminal OPEN_BRACE;
terminal PLUS;
terminal MINUS;
terminal TIMES;
terminal DIVIDE;
terminal MOD;
terminal LSHIFT;
terminal RSHIFT;
terminal LESS_THAN;
terminal GREATER_THAN;
terminal EQCOMPARE;
terminal BITWISE_AND;
terminal BITWISE_OR;
terminal BITWISE_NOT;
terminal AND;
terminal OR;
terminal QUESTION;
terminal COLON;

terminal java.lang.String  WIRES_TO;
terminal java.lang.String  EQUALS;
terminal java.lang.String  PREPROCESSOR;
terminal java.lang.String  CLOSE_BRACE;
terminal java.lang.String  IDENTIFIER;
terminal java.lang.Integer INTEGER_LITERAL;


/* Non Terminals used in the Grammar Section.
 *
 * Non Terminals that have an object value are listed first and then Non
 * Terminals that have an integer value are listed.  An object value means
 * that it can be any type, it isn't set to a specific type.  So it could
 * be an integer or a String or whatever.
 */
//non terminal nonNullExprList;
//non terminal exprNoCommas;
//non terminal castExpr;
//non terminal primary;
//non terminal Object     parms;
//non terminal Object     parm;

non terminal dispatch;
non terminal Component                  component;
non terminal NcHeader                   ncHeader;
non terminal IncludesList               includesList;
non terminal Includes                   includes;
non terminal IncludeList                includeList;
non terminal Configuration              configuration;
non terminal RequiresOrProvidesList     requiresOrProvidesList;
non terminal RequiresOrProvides         requiresOrProvides;
non terminal ParameterisedInterfaceList requires;
non terminal ParameterisedInterfaceList provides;
non terminal ParameterisedInterfaceList parameterisedInterfaceList;
non terminal ParameterisedInterfaces    parameterisedInterfaces;
non terminal ParameterisedInterface     parameterisedInterface;
non terminal InterfaceRef               interfaceRef;
non terminal java.lang.String           interfaceType;
non terminal java.lang.String           parameters;
non terminal IConfiguration             iconfiguration;
non terminal ConfigurationDecls         configurationDecls;
non terminal ConfigurationDecl          configurationDecl;
non terminal Connection                 connection;
non terminal Endpoint                   endpoint;
non terminal ParameterisedIdentifier    parameterisedIdentifier;
non terminal Cuses                      cuses;
non terminal ComponentList              componentList;
non terminal ComponentRef               componentRef;




/* -------------Precedence and Associatively of Terminals Section----------- */

/* Precedence of Non Terminals could be defined here.  If you do define
 * precedence here you won't need to worry about precedence in the Grammar
 * Section.  i.e. that TIMES should have a higher precedence than PLUS.
 *
 * The precedence defined here would look something like this where the lower
 * line always will have higher precedence than the line before it.
 *
 * precedence left PLUS, MINUS;
 * precedence left TIMES, DIVIDE;
 */

precedence left EQUALS;
precedence right QUESTION, COLON;
precedence left OR;
precedence left AND;
precedence left BITWISE_OR;
precedence left BITWISE_NOT;
precedence left BITWISE_AND;
precedence left EQCOMPARE;
precedence left LESS_THAN, GREATER_THAN;
precedence left LSHIFT, RSHIFT;
precedence left PLUS, MINUS;
precedence left TIMES, DIVIDE, MOD;
precedence left WIRES_TO, DOT, OPEN_PAREN, OPEN_BRACE;

/* ---------------------------------Grammar Section------------------------- */

/* The grammar for our parser.

        expr_list ::=   expr_list expr_part
                        | expr_part
        expr_part ::=   expr SEMI
        expr      ::=   factor PLUS expr
                        | factor MINUS expr
                        | factor
        factor    ::=   factor TIMES term
                        | factor DIVIDE term
                        | term
        primary   ::=   LPAREN expr RPAREN
                        | NUMBER
                        | ID

*/

start with dispatch;
 
dispatch ::=
    /* interface | */
    component : c {:
        parser.setComponent(c);
    :}
    ;

component  ::=
    /* ncHeader module | */
    ncHeader : h configuration : c {:
        RESULT = new Component(h, c);
    :}
    ;

ncHeader ::=
     includesList : list {:
         RESULT = new NcHeader(list);
     :}
     ;


includesList ::=
      includesList : list includes : i {:
          RESULT = new IncludesList(list, i);
      :}
      |
      /* lambda */
      ;

includes ::=
    INCLUDES includeList : list SEMI_COLON {:
        RESULT = new Includes(list);
    :}
    ;

includeList ::=
    IDENTIFIER : i {:
        RESULT = new IncludeList(i);
    :}
    |
    includeList : list COMMA IDENTIFIER : i {:
        RESULT = new IncludeList(list, i);
    :}
    ;

configuration ::=
    CONFIGURATION IDENTIFIER : i /*componentParms nescAttributes*/
                          OPEN_CURLY requiresOrProvidesList : list CLOSE_CURLY
                              iconfiguration : iconf {:
        RESULT = new Configuration(i, list, iconf);
    :}
    ;

iconfiguration ::=
    IMPLEMENTATION OPEN_CURLY configurationDecls : cds CLOSE_CURLY {:
        RESULT = new IConfiguration(cds);
    :}
    ;

configurationDecls ::=
    configurationDecls : cds configurationDecl : cd {:
        RESULT = new ConfigurationDecls(cds, cd);
    :}
    |
    /* lambda */
    ;

configurationDecl ::=
    connection : c {:
        RESULT = new ConfigurationDecl(c);
    :}
    /*
    | just_datadef
    */
    | cuses : c {:
        RESULT = new ConfigurationDecl(c);
    :}
    ;

connection ::=
    endpoint : left EQUALS : connType endpoint : right SEMI_COLON {:
        RESULT = new Connection(left, connType, right);
    :}
    |
    endpoint : left WIRES_TO : connType  endpoint : right SEMI_COLON {:
        RESULT = new Connection(left, connType, right);
    :}
/*
    What's a TASTNIOP?
    |
    endpoint TASTNIOP endpoint ';'
*/
    ;

endpoint ::=
    endpoint : e DOT parameterisedIdentifier : id {:
        RESULT = new Endpoint(e, id);
    :}
    |
    parameterisedIdentifier : id {:
        RESULT = new Endpoint(id);
    :}
    ;

parameterisedIdentifier ::=
    IDENTIFIER : id {:
        RESULT = new ParameterisedIdentifier(id);
    :}
    |
    /*
    IDENTIFIER OPEN_BRACE nonNullExprList CLOSE_BRACE
    */
    IDENTIFIER : id OPEN_BRACE /*content in CLOSE_BRACE*/ CLOSE_BRACE : parms {:
        RESULT = new ParameterisedIdentifier(id, parms);
    :}
    ;

/*
nonNullExprList ::=
    exprNoCommas
    |
    nonNullExprList COMMA exprNoCommas
    ;

exprNoCommas ::=
    castExpr
    |
    exprNoCommas PLUS exprNoCommas
    |
    exprNoCommas MINUS exprNoCommas
    |
    exprNoCommas TIMES exprNoCommas
    |
    exprNoCommas DIVIDE exprNoCommas
    |
    exprNoCommas MOD exprNoCommas
    |
    exprNoCommas LSHIFT exprNoCommas
    |
    exprNoCommas RSHIFT exprNoCommas
    |
    exprNoCommas LESS_THAN exprNoCommas
    |
    exprNoCommas GREATER_THAN exprNoCommas
    |
    exprNoCommas EQCOMPARE exprNoCommas
    |
    exprNoCommas BITWISE_AND exprNoCommas
    |
    exprNoCommas BITWISE_OR exprNoCommas
    |
    exprNoCommas BITWISE_NOT exprNoCommas
    |
    exprNoCommas AND exprNoCommas
    |
    exprNoCommas OR exprNoCommas
    |
    exprNoCommas QUESTION expr COLON exprNoCommas
    |
    exprNoCommas QUESTION COLON exprNoCommas
    |
    exprNoCommas EQUALS exprNoCommas
    ;
*/

// castExpr ::=
//     unaryExpr
//     /*
//     |
//     ...
//      */
//     ;
// 
// unaryExpr ::=
//     
//    ;
//
//expr ::=
//    nonNullExprList
//    |
//    /* lambda */
//    ;

cuses ::=
    COMPONENTS componentList : list SEMI_COLON {:
        RESULT = new Cuses(list);
    :}
    ;

componentList ::=
    componentList : list COMMA componentRef : ref{:
        RESULT = new ComponentList(list, ref);
    :}
    |
    componentRef : ref {:
        RESULT = new ComponentList(ref);
    :}
    ;

componentRef ::=
    IDENTIFIER : id {:
        RESULT = new ComponentRef(id);
    :}
    |
    IDENTIFIER : id AS IDENTIFIER : rename {:
        RESULT = new ComponentRef(id, rename);
    :}
    ;

requiresOrProvidesList ::=
    requiresOrProvidesList : list requiresOrProvides : reqOrProv {:
        RESULT = new RequiresOrProvidesList(list, reqOrProv);
    :}
    |
    /* lambda */
    ;

requiresOrProvides ::=
    requires : req {:
        RESULT = new RequiresOrProvides(true, req);
    :}
    |
    provides : prov {:
        RESULT = new RequiresOrProvides(false, prov);
    :}
    ;

requires ::=
    USES parameterisedInterfaceList : list {:
        RESULT = list;
    :}
    ;

provides ::=
    PROVIDES parameterisedInterfaceList : list {:
        RESULT = list;
    :}
    ;

parameterisedInterfaceList ::=
    parameterisedInterface : pi {:
        RESULT = new ParameterisedInterfaceList(pi);
    :}
    |
    OPEN_CURLY parameterisedInterfaces : pis CLOSE_CURLY {:
        RESULT = new ParameterisedInterfaceList(pis);
    :}
    ;

parameterisedInterfaces ::=
    parameterisedInterfaces : pis parameterisedInterface : pi {:
        RESULT = new ParameterisedInterfaces(pis, pi);
    :}
    |
    parameterisedInterface : pi {:
        RESULT = new ParameterisedInterfaces(pi);
    :}
    ;

parameterisedInterface ::=
/*
    just_datadef
    |
*/
    interfaceRef : ref /*nescAttributes*/ SEMI_COLON {:
        RESULT = new ParameterisedInterface(ref);
    :}
    |
    interfaceRef : ref parameters : p /*nescAttributes*/ SEMI_COLON {:
        RESULT = new ParameterisedInterface(ref, p);
    :}
    ;

interfaceRef ::=
    interfaceType : type {:
        RESULT = new InterfaceRef(type);
    :}
    |
    interfaceType : type AS IDENTIFIER : i {:
        RESULT = new InterfaceRef(type, i);
    :}
    ;

interfaceType ::=
    INTERFACE IDENTIFIER : i {:
        RESULT = i;
    :}
/*
    |
    INTERFACE idword '<' typelist '>'
*/
    ;


parameters ::=
    /* OPEN_BRACE parms CLOSE_BRACE */
    OPEN_BRACE /*content in CLOSE_BRACE*/ CLOSE_BRACE : content  {:
        RESULT = content;
    :}
    ;

/*
parms ::=
    parm
    |
    parms COMMA parm
    ;

parm ::=
    IDENTIFIER:i IDENTIFIER:j {:
        System.out.println("Type: " + i + "  name: " + j);
    :}
    declspecs_ts xreferror parm_declarator maybe_attribute
    |
    declspecs_ts xreferror notype_declarator maybe_attribute
    |
    declspecs_ts xreferror absdcl
    |
    declspecs_ts xreferror absdcl1_noea attributes
    |
    declspecs_nots xreferror notype_declarator maybe_attribute
    |
    declspecs_nots xreferror absdcl
    |
    declspecs_nots xreferror absdcl1_noea attributes
    ;
*/

/* vim: :set ft=java: */
